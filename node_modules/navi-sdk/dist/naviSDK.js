"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NAVISDKClient = void 0;
const AccountManager_1 = require("./libs/AccountManager");
const PoolInfo_1 = require("./libs/PoolInfo");
const bip39 = __importStar(require("@scure/bip39"));
const english_1 = require("@scure/bip39/wordlists/english");
const address_1 = require("./address");
class NAVISDKClient {
    /**
     * Generates a new NAVISDKClient instance.
     * @param mnemonic - The mnemonic phrase to use for account generation. If not provided, a new mnemonic will be generated.
     * @param networkType - The network type to use. Defaults to "mainnet".
     * @param wordLength - The length of the mnemonic phrase. Defaults to 12.
     * @param numberOfAccounts - The number of accounts to generate. Defaults to 10.
     */
    constructor({ mnemonic, networkType, wordLength = 12, numberOfAccounts = 10 } = {}) {
        this.accounts = [];
        this.mnemonic = "";
        this.networkType = "";
        if (mnemonic === undefined) {
            this.mnemonic = bip39.generateMnemonic(english_1.wordlist, wordLength === 12 ? 128 : 256);
        }
        else {
            this.mnemonic = mnemonic;
        }
        this.networkType = networkType || "mainnet";
        for (let i = 0; i < numberOfAccounts; i++) {
            this.account = new AccountManager_1.AccountManager({ mnemonic: this.mnemonic || "", networkType: this.networkType || "mainnet", wordLength: wordLength || 12, accountIndex: i });
            this.accounts.push(this.account);
        }
        console.log("Network Type: ", networkType || "mainnet");
    }
    /**
     * Retrieves all accounts stored in the Navi SDK.
     *
     * @returns An array of all accounts.
     */
    getAllAccounts() {
        this.accounts.forEach((account, index) => {
            console.log(`index:${index}, address: ${account.getPublicKey()}`);
        });
        return this.accounts;
    }
    /**
     * Retrieves the mnemonic associated with the Navi SDK instance.
     *
     * @returns The mnemonic string.
     */
    getMnemonic() {
        console.log(`mnemonic: ${this.mnemonic}`);
        return this.mnemonic;
    }
    /**
     * Retrieves the pool information for a specific coin symbol.
     * If no coin symbol is provided, it retrieves the pool information for all coins.
     * @param coinType The dataType of the coin for which to retrieve the pool information.
     * @returns A Promise that resolves to the pool information.
     */
    getPoolInfo(coinType) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, PoolInfo_1.getPoolInfo)(coinType.symbol);
        });
    }
    /**
     * Retrieves the reserves for the first account.
     * @returns {Promise<void>} A promise that resolves when the reserves are retrieved.
     */
    getReserves() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.accounts[0].getReserves();
        });
    }
    /**
     * Retrieves the reserve detail for a given asset ID.
     * @param conType - The CoinInfo data type for which to retrieve the reserve detail
     * @returns A Promise that resolves when the reserve detail is retrieved.
     */
    getReserveDetail(conType) {
        return __awaiter(this, void 0, void 0, function* () {
            const reserve = address_1.pool[conType.symbol];
            return yield this.accounts[0].getReservesDetail(reserve.assetId);
        });
    }
    /**
     * Retrieves the health factor for a given address.
     *
     * @param address - The address for which to retrieve the health factor.
     * @returns A promise that resolves to the health factor value.
     */
    getHealthFactor(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accounts.length === 0) {
                this.account = new AccountManager_1.AccountManager();
                this.accounts.push(this.account);
                yield this.accounts[0].getHealthFactor(address);
                this.accounts.splice(0, 1);
            }
            return yield this.accounts[0].getHealthFactor(address);
        });
    }
    /**
     * Retrieves the dynamic health factor for a given address and pool.
     *
     * @param address - The address to retrieve the dynamic health factor for.
     * @param coinType - The Type of the pool.
     * @param estimateSupply - The estimated supply value.
     * @param estimateBorrow - The estimated borrow value.
     * @param is_increase - A boolean indicating whether to increase the dynamic health factor.
     * @returns A Promise that resolves to the dynamic health factor.
     */
    getDynamicHealthFactor(address, coinType, estimateSupply, estimateBorrow, is_increase = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.accounts.length === 0) {
                this.account = new AccountManager_1.AccountManager();
                this.accounts.push(this.account);
                yield this.accounts[0].getDynamicHealthFactorAll(address, coinType.symbol, estimateSupply, estimateBorrow, is_increase);
                this.accounts.splice(0, 1);
            }
            yield this.accounts[0].getDynamicHealthFactorAll(address, coinType.symbol, estimateSupply, estimateBorrow, is_increase);
        });
    }
    /**
     * Retrieves all NAVI portfolios for the accounts.
     * @returns A promise that resolves to an array of results for each account.
     */
    getAllNaviPortfolios() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all(this.accounts.map(account => account.getNAVIPortfolio(account.address, false)));
            const balanceMap = new Map();
            results.forEach((result) => {
                result.forEach((value, key) => {
                    if (balanceMap.has(key)) {
                        const balance = balanceMap.get(key);
                        balance.borrowBalance += value.borrowBalance;
                        balance.supplyBalance += value.supplyBalance;
                        balanceMap.set(key, balance);
                    }
                    else {
                        balanceMap.set(key, value);
                    }
                });
            });
            return balanceMap;
        });
    }
    /**
     * Retrieves the balances of all accounts.
     * @returns A record containing the balances of each coin.
     */
    getAllBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            const balancePromises = this.accounts.map(account => account.getWalletBalance(false));
            const balancesAll = yield Promise.all(balancePromises);
            const coinBalances = {};
            balancesAll.forEach(balance => {
                Object.entries(balance).forEach(([coin, amount]) => {
                    if (coinBalances[coin]) {
                        coinBalances[coin] += amount;
                    }
                    else {
                        coinBalances[coin] = amount;
                    }
                });
            });
            return coinBalances;
        });
    }
    /**
     * Checks the available rewards for a given address.
     * @param address - The address to check rewards for.
     * @param option - The option type for rewards.
     * @returns A promise that resolves with the available rewards.
     */
    getAvailableRewards(address = this.accounts[0].address, option = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.accounts[0].getAvailableRewards(address, option, true);
        });
    }
}
exports.NAVISDKClient = NAVISDKClient;
