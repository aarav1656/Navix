"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveInspect = void 0;
const transactions_1 = require("@mysten/sui.js/transactions");
const bcs_1 = require("@mysten/sui.js/bcs");
/**
 * Parses and prints the inspection results.
 * @param data - The inspection results to be parsed and printed.
 * @param funName - The name of the function being inspected.
 * @param parseType - The type of parsing to be applied (optional).
 * @returns An array of parsed values.
 */
function inspectResultParseAndPrint(data, funName, parseType) {
    if (data.results && data.results.length > 0) {
        if (data.results[0].returnValues && data.results[0].returnValues.length > 0) {
            let values = [];
            for (let v of data.results[0].returnValues) {
                const _type = parseType ? parseType : v[1];
                let result = bcs_1.bcs.de(_type, Uint8Array.from(v[0]));
                values.push(result);
            }
            return values;
        }
    }
    else if (data.error) {
        console.log(`Get an error, msg: ${data.error}`);
    }
}
/**
 * Executes the specified function on the provided transaction block and prints the inspection result.
 * @param txb - The transaction block to execute the function on.
 * @param client - The SuiClient instance.
 * @param sender - The sender of the transaction block.
 * @param funName - The name of the function to execute.
 * @param typeName - Optional. The type name associated with the function.
 * @returns A promise that resolves to the inspection result.
 */
function moveInspectImpl(txb, client, sender, funName, typeName) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield client.devInspectTransactionBlock({
            transactionBlock: txb,
            sender: sender,
        });
        return inspectResultParseAndPrint(result, funName, typeName);
    });
}
/**
 * Moves and inspects a function call.
 * @param client - The SuiClient object.
 * @param sender - The sender of the function call.
 * @param target - The target of the function call in the format `${string}::${string}::${string}`.
 * @param args - The arguments for the function call.
 * @param typeArgs - Optional type arguments for the function call.
 * @param typeName - Optional type name for the function call.
 * @returns A Promise that resolves to the result of the move and inspect operation.
 */
function moveInspect(client, sender, target, args, typeArgs, typeName) {
    return __awaiter(this, void 0, void 0, function* () {
        const tx = new transactions_1.TransactionBlock();
        const args_ = [];
        for (let arg of args) {
            args_.push(tx.pure(arg));
        }
        const funcName = target.split('::');
        tx.moveCall({
            target: target,
            arguments: args_,
            typeArguments: typeArgs,
        });
        return yield moveInspectImpl(tx, client, sender, funcName.slice(1, 3).join('::'), typeName);
    });
}
exports.moveInspect = moveInspect;
