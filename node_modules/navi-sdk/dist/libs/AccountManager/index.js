"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountManager = void 0;
const ed25519_1 = require("@mysten/sui.js/keypairs/ed25519");
const client_1 = require("@mysten/sui.js/client");
const Coins_1 = require("../Coins");
const transactions_1 = require("@mysten/sui.js/transactions");
const address_1 = require("../../address");
const PTB_1 = require("../PTB");
const CallFunctions_1 = require("../CallFunctions");
const bcs_1 = require("@mysten/sui.js/bcs");
const assert_1 = __importDefault(require("assert"));
class AccountManager {
    /**
     * AccountManager class for managing user accounts.
     */
    constructor({ mnemonic = "", networkType, accountIndex = 0 } = {}) {
        this.address = "";
        this.keypair = ed25519_1.Ed25519Keypair.deriveKeypair(mnemonic, this.getDerivePath(accountIndex));
        this.client = new client_1.SuiClient({
            url: (0, client_1.getFullnodeUrl)(networkType),
        });
        this.address = this.keypair.getPublicKey().toSuiAddress();
        this.structRegistry();
    }
    structRegistry() {
        bcs_1.bcs.registerStructType('IncentiveAPYInfo', {
            asset_id: 'u8',
            apy: 'u256',
            coin_types: 'vector<string>',
        });
        bcs_1.bcs.registerStructType('IncentivePoolInfo', {
            pool_id: 'address',
            funds: 'address',
            phase: 'u64',
            start_at: 'u64',
            end_at: 'u64',
            closed_at: 'u64',
            total_supply: 'u64',
            asset_id: 'u8',
            option: 'u8',
            factor: 'u256',
            distributed: 'u64',
            available: 'u256',
            total: 'u256',
        });
        bcs_1.bcs.registerStructType('IncentivePoolInfoByPhase', {
            phase: 'u64',
            pools: 'vector<IncentivePoolInfo>',
        });
        bcs_1.bcs.registerStructType('UserStateInfo', {
            asset_id: 'u8',
            borrow_balance: 'u256',
            supply_balance: 'u256',
        });
        bcs_1.bcs.registerStructType('ReserveDataInfo', {
            id: 'u8',
            oracle_id: 'u8',
            coin_type: 'string',
            supply_cap: 'u256',
            borrow_cap: 'u256',
            supply_rate: 'u256',
            borrow_rate: 'u256',
            supply_index: 'u256',
            borrow_index: 'u256',
            total_supply: 'u256',
            total_borrow: 'u256',
            last_update_at: 'u64',
            ltv: 'u256',
            treasury_factor: 'u256',
            treasury_balance: 'u256',
            base_rate: 'u256',
            multiplier: 'u256',
            jump_rate_multiplier: 'u256',
            reserve_factor: 'u256',
            optimal_utilization: 'u256',
            liquidation_ratio: 'u256',
            liquidation_bonus: 'u256',
            liquidation_threshold: 'u256',
        });
    }
    /**
     * Returns the derivation path for a given address index.
     * @param addressIndex - The index of the address.
     * @returns The derivation path.
     */
    getDerivePath(addressIndex) {
        return `m/44'/784'/0'/0'/${addressIndex}'`;
    }
    ;
    /**
     * Retrieves the public key associated with the account.
     * @returns The public key as a SuiAddress.
     */
    getPublicKey() {
        return this.keypair.getPublicKey().toSuiAddress();
    }
    /**
     * getAllCoins is an asynchronous function that retrieves all the coins owned by the account.
     *
     * @param ifPrettyPrint - A boolean indicating whether to print the data in a pretty format. Default is true.
     * @returns A Promise that resolves to the data containing all the coins owned by the account.
     */
    getAllCoins(ifPrettyPrint = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const allData = yield this.client.getAllCoins({
                owner: this.address,
            });
            if (ifPrettyPrint) {
                allData.data.forEach((element) => {
                    console.log("Coin Type: ", element.coinType, "| Obj id: ", element.coinObjectId, " | Balance: ", element.balance);
                });
            }
            return allData;
        });
    }
    /**
     * getWalletBalance is an asynchronous function that retrieves the balance of all coins in the wallet.
     *
     * @param ifPrettyPrint - A boolean indicating whether to print the data in a pretty format. Default is false.
     * @returns A Promise that resolves to an object containing the balance of each coin in the wallet.
     */
    getWalletBalance(ifPrettyPrint = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const allData = yield this.getAllCoins(false);
            const coinBalances = {};
            yield Promise.all(allData.data.map((element) => __awaiter(this, void 0, void 0, function* () {
                const coinType = element.coinType;
                const balance = element.balance;
                const decimal = yield this.getCoinDecimal(coinType);
                if (coinBalances[coinType]) {
                    coinBalances[coinType] += Number(balance) / Math.pow(10, decimal);
                }
                else {
                    coinBalances[coinType] = Number(balance) / Math.pow(10, decimal);
                }
            })));
            if (ifPrettyPrint) {
                for (const coinType in coinBalances) {
                    if (address_1.AddressMap.hasOwnProperty(coinType)) {
                        console.log("Coin Type: ", address_1.AddressMap[coinType], "| Balance: ", coinBalances[coinType]);
                    }
                    else {
                        console.log("Unknown Coin Type: ", coinType, "| Balance: ", coinBalances[coinType]);
                    }
                }
            }
            return coinBalances;
        });
    }
    /**
     * Retrieves coin objects based on the specified coin type.
     * @param coinType - The coin type to retrieve coin objects for. Defaults to "0x2::sui::SUI".
     * @returns A Promise that resolves to the retrieved coin objects.
     */
    getCoins(coinType = "0x2::sui::SUI") {
        return __awaiter(this, void 0, void 0, function* () {
            const coinAddress = coinType.address ? coinType.address : coinType;
            const coininfo = yield this.client.getCoins({
                owner: this.address,
                coinType: coinAddress
            });
            return coininfo;
        });
    }
    /**
     * Creates an account capability.
     * @returns A Promise that resolves to the result of the account creation.
     */
    createAccountCap() {
        return __awaiter(this, void 0, void 0, function* () {
            let txb = new transactions_1.TransactionBlock();
            let sender = this.getPublicKey();
            txb.setSender(sender);
            const config = yield (0, address_1.getConfig)();
            const [ret] = txb.moveCall({
                target: `${config.ProtocolPackage}::lending::create_account`,
            });
            txb.transferObjects([ret], this.getPublicKey());
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
    /**
     * Sends coins to multiple recipients.
     *
     * @param coinType - The type of coin to send.
     * @param recipient - An array of recipient addresses.
     * @param amounts - An array of amounts to send to each recipient.
     * @returns A promise that resolves to the result of the transaction.
     * @throws An error if the number of recipients does not match the number of amounts, or if the sender has insufficient balance.
     */
    sendCoinToMany(coinType, recipient, amounts) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinAddress = coinType.address ? coinType.address : coinType;
            // Check if any recipient address is an empty string
            if (recipient.some(address => address.trim() === "")) {
                throw new Error("Recipient list contains an empty address string.");
            }
            if (recipient.length !== amounts.length) {
                throw new Error("transferSuiToMany: recipients.length !== amounts.length");
            }
            let sender = this.getPublicKey();
            const coinBalance = yield (0, Coins_1.getCoinAmount)(this.client, this.getPublicKey(), coinAddress);
            if (coinBalance > 0 &&
                coinBalance >= amounts.reduce((a, b) => a + b, 0)) {
                const txb = new transactions_1.TransactionBlock();
                txb.setSender(sender);
                let getCoinInfo = yield this.getCoins(coinAddress);
                let coins;
                if (coinAddress == "0x2::sui::SUI") {
                    coins = txb.splitCoins(txb.gas, amounts);
                }
                else {
                    //Merge other coins to one obj if there are multiple
                    if (getCoinInfo.data.length >= 2) {
                        let baseObj = getCoinInfo.data[0].coinObjectId;
                        let i = 1;
                        while (i < getCoinInfo.data.length) {
                            txb.mergeCoins(baseObj, [getCoinInfo.data[i].coinObjectId]);
                            i++;
                        }
                    }
                    let mergedCoin = txb.object(getCoinInfo.data[0].coinObjectId);
                    coins = txb.splitCoins(mergedCoin, amounts);
                }
                recipient.forEach((address, index) => {
                    txb.transferObjects([coins[index]], address);
                });
                const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
                return result;
            }
            else {
                throw new Error("Insufficient balance for this Coin");
            }
        });
    }
    /**
     * Sends a specified amount of coins to a recipient.
     *
     * @param coinType - The type of coin to send.
     * @param recipient - The address of the recipient.
     * @param amount - The amount of coins to send.
     * @returns A promise that resolves when the coins are sent.
     */
    sendCoin(coinType, recipient, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinAddress = coinType.address ? coinType.address : coinType;
            return yield this.sendCoinToMany(coinAddress, [recipient], [amount]);
        });
    }
    /**
     * Transfers multiple objects to multiple recipients.
     * @param objects - An array of objects to be transferred.
     * @param recipients - An array of recipients for the objects.
     * @returns A promise that resolves with the result of the transfer.
     * @throws An error if the length of objects and recipient arrays are not the same.
     */
    transferObjsToMany(objects, recipients) {
        return __awaiter(this, void 0, void 0, function* () {
            if (objects.length !== recipients.length) {
                throw new Error("The length of objects and recipient should be the same");
            }
            else {
                let sender = this.getPublicKey();
                const txb = new transactions_1.TransactionBlock();
                txb.setSender(sender);
                objects.forEach((object, index) => {
                    txb.transferObjects([txb.object(object)], recipients[index]);
                });
                const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
                return result;
            }
        });
    }
    /**
     * Transfers an object to a recipient.
     * @param object - The object to be transferred.
     * @param recipient - The recipient of the object.
     * @returns A promise that resolves when the transfer is complete.
     */
    transferObj(object, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.transferObjsToMany([object], [recipient]);
        });
    }
    /**
     * Deposits a specified amount of a given coin type to Navi.
     * @param coinType - The coin type to deposit.
     * @param amount - The amount to deposit.
     * @returns A promise that resolves to the result of the deposit transaction.
     * @throws An error if there is insufficient balance for the coin.
     */
    depositToNavi(coinType, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinSymbol = coinType.symbol;
            let txb = new transactions_1.TransactionBlock();
            let sender = this.getPublicKey();
            txb.setSender(sender);
            const pool_real = address_1.pool[coinSymbol];
            let getCoinInfo = yield this.getCoins(coinType.address);
            if (!getCoinInfo.data[0]) {
                throw new Error("Insufficient balance for this Coin");
            }
            if (coinSymbol == "Sui") {
                const [to_deposit] = txb.splitCoins(txb.gas, [amount]);
                yield (0, PTB_1.depositCoin)(txb, pool_real, to_deposit, amount);
            }
            else {
                //Try to merge all the tokens to one object
                const mergedCoinObject = (0, PTB_1.mergeCoins)(txb, getCoinInfo);
                yield (0, PTB_1.depositCoin)(txb, pool_real, mergedCoinObject, amount);
            }
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
    /**
     * Deposits a specified amount of a given coin type to Navi with an account cap address.
     * @param coinType - The coin type to deposit.
     * @param amount - The amount to deposit.
     * @param accountCapAddress - The account cap address.
     * @returns A promise that resolves to the result of the deposit transaction.
     * @throws An error if there is insufficient balance for the coin.
     */
    depositToNaviWithAccountCap(coinType, amount, accountCapAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinSymbol = coinType.symbol ? coinType.symbol : coinType;
            let txb = new transactions_1.TransactionBlock();
            let sender = this.getPublicKey();
            txb.setSender(sender);
            const pool_real = address_1.pool[coinSymbol];
            let getCoinInfo = yield this.getCoins(coinType.address);
            if (!getCoinInfo.data[0]) {
                throw new Error("Insufficient balance for this Coin");
            }
            if (coinSymbol == "Sui") {
                const [to_deposit] = txb.splitCoins(txb.gas, [amount]);
                yield (0, PTB_1.depositCoinWithAccountCap)(txb, pool_real, to_deposit, accountCapAddress);
            }
            else {
                //Try to merge all the tokens to one object
                const mergedCoinObject = (0, PTB_1.mergeCoins)(txb, getCoinInfo);
                yield (0, PTB_1.depositCoinWithAccountCap)(txb, pool_real, mergedCoinObject, accountCapAddress);
            }
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
    /**
     * Withdraws a specified amount of coins.
     * @param coinType - The type of coin to withdraw.
     * @param amount - The amount of coins to withdraw.
     * @returns A promise that resolves to the result of the withdrawal.
     */
    withdraw(coinType, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinSymbol = coinType.symbol ? coinType.symbol : coinType;
            let txb = new transactions_1.TransactionBlock();
            let sender = this.getPublicKey();
            txb.setSender(sender);
            const pool_real = address_1.pool[coinSymbol];
            const [returnCoin] = yield (0, PTB_1.withdrawCoin)(txb, pool_real, amount);
            txb.transferObjects([returnCoin], sender);
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
    /**
     * Withdraws a specified amount of coins with an account cap.
     *
     * @param coinType - The type of coin to withdraw.
     * @param withdrawAmount - The amount of coins to withdraw.
     * @param accountCapAddress - The address of the account cap.
     * @returns A promise that resolves to the result of the withdrawal.
     */
    withdrawWithAccountCap(coinType, withdrawAmount, accountCapAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinSymbol = coinType.symbol ? coinType.symbol : coinType;
            let txb = new transactions_1.TransactionBlock();
            let sender = this.getPublicKey();
            txb.setSender(sender);
            const pool_real = address_1.pool[coinSymbol];
            const [returnCoin] = yield (0, PTB_1.withdrawCoinWithAccountCap)(txb, pool_real, accountCapAddress, withdrawAmount, sender);
            txb.transferObjects([returnCoin], sender);
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
    /**
     * Borrows a specified amount of a given coin.
     *
     * @param coinType - The type of coin to borrow.
     * @param borrowAmount - The amount of the coin to borrow.
     * @returns A promise that resolves to the result of the borrowing operation.
     */
    borrow(coinType, borrowAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinSymbol = coinType.symbol ? coinType.symbol : coinType;
            let txb = new transactions_1.TransactionBlock();
            let sender = this.getPublicKey();
            txb.setSender(sender);
            const pool_real = address_1.pool[coinSymbol];
            const [returnCoin] = yield (0, PTB_1.borrowCoin)(txb, pool_real, borrowAmount);
            txb.transferObjects([returnCoin], sender);
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
    /**
     * Repays a specified amount of a given coin type.
     *
     * @param coinType - The coin type or coin symbol to repay.
     * @param repayAmount - The amount to repay.
     * @returns A promise that resolves to the result of the repayment transaction.
     * @throws An error if there is insufficient balance for the specified coin.
     */
    repay(coinType, repayAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinSymbol = coinType.symbol ? coinType.symbol : coinType;
            let txb = new transactions_1.TransactionBlock();
            let sender = this.getPublicKey();
            txb.setSender(sender);
            const pool_real = address_1.pool[coinSymbol];
            let getCoinInfo = yield this.getCoins(coinType.address);
            if (!getCoinInfo.data[0]) {
                throw new Error("Insufficient balance for this Coin");
            }
            if (coinSymbol == "Sui") {
                const [to_deposit] = txb.splitCoins(txb.gas, [repayAmount]);
                yield (0, PTB_1.repayDebt)(txb, pool_real, to_deposit, repayAmount);
            }
            else {
                //Try to merge all the tokens to one object
                const mergedCoinObject = (0, PTB_1.mergeCoins)(txb, getCoinInfo);
                yield (0, PTB_1.repayDebt)(txb, pool_real, mergedCoinObject, repayAmount);
            }
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
    liquidate(payCoinType, to_liquidate_address, collateralCoinType, to_liquidate_amount = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            let txb = new transactions_1.TransactionBlock();
            txb.setSender(this.address);
            let getCoinInfo = yield this.getCoins(payCoinType.address);
            let allBalance = yield this.client.getBalance({ owner: this.address, coinType: payCoinType.address });
            let { totalBalance } = allBalance;
            if (to_liquidate_amount != 0) {
                (0, assert_1.default)(to_liquidate_amount * Math.pow(10, payCoinType.decimal) <= Number(totalBalance), "Insufficient balance for this Coin, please don't apply decimals to to_liquidate_amount");
                totalBalance = (to_liquidate_amount * Math.pow(10, payCoinType.decimal)).toString();
            }
            if (payCoinType.symbol == "Sui") {
                totalBalance = (Number(totalBalance) - 0.5 * 1e9).toString(); //You need to keep some Sui for gas
                let [mergedCoin] = txb.splitCoins(txb.gas, [totalBalance]);
                yield (0, PTB_1.liquidateFunction)(txb, payCoinType, mergedCoin, collateralCoinType, to_liquidate_address, totalBalance);
            }
            else {
                if (getCoinInfo.data.length >= 2) {
                    const txbMerge = new transactions_1.TransactionBlock();
                    txbMerge.setSender(this.address);
                    let baseObj = getCoinInfo.data[0].coinObjectId;
                    let i = 1;
                    while (i < getCoinInfo.data.length) {
                        txbMerge.mergeCoins(baseObj, [getCoinInfo.data[i].coinObjectId]);
                        i++;
                    }
                    (0, PTB_1.SignAndSubmitTXB)(txbMerge, this.client, this.keypair);
                }
                let mergedCoin = txb.object(getCoinInfo.data[0].coinObjectId);
                yield (0, PTB_1.liquidateFunction)(txb, payCoinType, mergedCoin, collateralCoinType, to_liquidate_address, totalBalance);
            }
            if (payCoinType.symbol == "Sui") {
                totalBalance = (Number(totalBalance) - 0.5 * 1e9).toString(); //You need to keep some Sui for gas
                let [mergedCoin] = txb.splitCoins(txb.gas, [totalBalance]);
                yield (0, PTB_1.liquidateFunction)(txb, payCoinType, mergedCoin, collateralCoinType, to_liquidate_address, totalBalance);
            }
            else {
                if (getCoinInfo.data.length >= 2) {
                    const txbMerge = new transactions_1.TransactionBlock();
                    txbMerge.setSender(this.address);
                    let baseObj = getCoinInfo.data[0].coinObjectId;
                    let i = 1;
                    while (i < getCoinInfo.data.length) {
                        txbMerge.mergeCoins(baseObj, [getCoinInfo.data[i].coinObjectId]);
                        i++;
                    }
                    (0, PTB_1.SignAndSubmitTXB)(txbMerge, this.client, this.keypair);
                }
                let mergedCoin = txb.object(getCoinInfo.data[0].coinObjectId);
                yield (0, PTB_1.liquidateFunction)(txb, payCoinType, mergedCoin, collateralCoinType, to_liquidate_address, totalBalance);
            }
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
    /**
     * Retrieves the health factor for a given address.
     * @param address - The address for which to retrieve the health factor. Defaults to the instance's address.
     * @returns The health factor as a number.
     */
    getHealthFactor(address = this.address) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield (0, address_1.getConfig)();
            const result = yield (0, CallFunctions_1.moveInspect)(this.client, this.getPublicKey(), `${config.ProtocolPackage}::logic::user_health_factor`, [
                '0x06', // clock object id
                config.StorageId, // object id of storage
                config.PriceOracle, // object id of price oracle
                address, // user address
            ]);
            const healthFactor = Number(result[0]) / Math.pow(10, 27);
            return healthFactor;
        });
    }
    /**
     * Retrieves the dynamic health factor for a given user in a specific pool.
     * @param sender - The address of the user.
     * @param poolName - The name of the pool.
     * @param estimateSupply - The estimated supply value (default: 0).
     * @param estimateBorrow - The estimated borrow value (default: 0).
     * @param is_increase - A boolean indicating whether the health factor is increasing (default: true).
     * @returns The health factor for the user in the pool.
     * @throws Error if the pool does not exist.
     */
    getDynamicHealthFactorAll(sender, poolName, estimateSupply = 0, estimateBorrow = 0, is_increase = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pool = address_1.pool[poolName];
            if (!_pool) {
                throw new Error("Pool does not exist");
            }
            const config = yield (0, address_1.getConfig)();
            const result = yield (0, CallFunctions_1.moveInspect)(this.client, this.getPublicKey(), `${config.ProtocolPackage}::dynamic_calculator::dynamic_health_factor`, [
                '0x06', // clock object id
                config.StorageId, // object id of storage
                config.PriceOracle, // object id of price oracle
                _pool.poolId,
                sender, // user address,
                _pool.assetId,
                estimateSupply,
                estimateBorrow,
                is_increase
            ], [_pool.type]);
            const healthFactor = Number(result[0]) / Math.pow(10, 27);
            if (estimateSupply > 0) {
                console.log('With EstimateSupply Change: ', `${estimateSupply}`, ' address: ', `${sender}`, ' health factor is: ', healthFactor.toString());
            }
            else if (estimateBorrow > 0) {
                console.log('With EstimateBorrow Change: ', `${estimateBorrow}`, ' address: ', `${sender}`, ' health factor is: ', healthFactor.toString());
            }
            else {
                console.log('address: ', `${sender}`, ' health factor is: ', healthFactor.toString());
            }
        });
    }
    /**
     * Retrieves the decimal value for a given coin type.
     * If the coin type has an address property, it uses that address. Otherwise, it uses the coin type itself.
     *
     * @param coinType - The coin type or coin object.
     * @returns The decimal value of the coin.
     */
    getCoinDecimal(coinType) {
        return __awaiter(this, void 0, void 0, function* () {
            const coinAddress = coinType.address ? coinType.address : coinType;
            const decimal = yield (0, Coins_1.getCoinDecimal)(this.client, coinAddress);
            return decimal;
        });
    }
    parseResult(msg) {
        console.log(JSON.stringify(msg, null, 2));
    }
    /**
     * Retrieves the reserves using the client's `getDynamicFields` method.
     * Parses the result using the `parseResult` method.
     */
    getReserves() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield (0, address_1.getConfig)();
            const result = yield this.client.getDynamicFields({ parentId: config.ReserveParentId });
            return result;
        });
    }
    /**
     * Retrieves the detailed information of a reserve based on the provided asset ID.
     * @param assetId - The ID of the asset for which to retrieve the reserve details.
     * @returns A Promise that resolves to the parsed result of the reserve details.
     */
    getReservesDetail(assetId) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield (0, address_1.getConfig)();
            const result = yield this.client.getDynamicFieldObject({ parentId: config.ReserveParentId, name: { type: 'u8', value: assetId } });
            return result;
        });
    }
    /**
     * Retrieves the NAVI portfolio for the current account.
     * @param ifPrettyPrint - A boolean indicating whether to print the portfolio in a pretty format. Default is true.
     * @returns A Promise that resolves to a Map containing the borrow and supply balances for each reserve.
     */
    getNAVIPortfolio(address = this.address, ifPrettyPrint = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const balanceMap = new Map();
            yield Promise.all(Object.keys(address_1.pool).map((poolKey) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
                const reserve = address_1.pool[poolKey];
                const borrowBalance = yield this.client.getDynamicFieldObject({ parentId: reserve.borrowBalanceParentId, name: { type: 'address', value: address } });
                const supplyBalance = yield this.client.getDynamicFieldObject({ parentId: reserve.supplyBalanceParentId, name: { type: 'address', value: address } });
                const borrowIndexData = yield this.getReservesDetail(reserve.assetId);
                const borrowIndex = ((_e = (_d = (_c = (_b = (_a = borrowIndexData.data) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.fields) === null || _c === void 0 ? void 0 : _c.value) === null || _d === void 0 ? void 0 : _d.fields) === null || _e === void 0 ? void 0 : _e.current_borrow_index) / Math.pow(10, 27);
                const supplyIndex = ((_k = (_j = (_h = (_g = (_f = borrowIndexData.data) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.fields) === null || _h === void 0 ? void 0 : _h.value) === null || _j === void 0 ? void 0 : _j.fields) === null || _k === void 0 ? void 0 : _k.current_supply_index) / Math.pow(10, 27);
                let borrowValue = borrowBalance && ((_m = (_l = borrowBalance.data) === null || _l === void 0 ? void 0 : _l.content) === null || _m === void 0 ? void 0 : _m.fields.value) !== undefined ? ((_p = (_o = borrowBalance.data) === null || _o === void 0 ? void 0 : _o.content) === null || _p === void 0 ? void 0 : _p.fields.value) / Math.pow(10, 9) : 0;
                let supplyValue = supplyBalance && ((_r = (_q = supplyBalance.data) === null || _q === void 0 ? void 0 : _q.content) === null || _r === void 0 ? void 0 : _r.fields.value) !== undefined ? ((_t = (_s = supplyBalance.data) === null || _s === void 0 ? void 0 : _s.content) === null || _t === void 0 ? void 0 : _t.fields.value) / Math.pow(10, 9) : 0;
                borrowValue *= borrowIndex;
                supplyValue *= supplyIndex;
                if (ifPrettyPrint) {
                    console.log(`| ${reserve.name} | ${borrowValue} | ${supplyValue} |`);
                }
                balanceMap.set(reserve.name, { borrowBalance: borrowValue, supplyBalance: supplyValue });
            })));
            return balanceMap;
        });
    }
    /**
     * Retrieves the incentive pools for a given asset and option.
     * @param asset_id - The ID of the asset.
     * @param option - The option type.
     * @param user - (Optional) The user's address. If provided, the rewards claimed by the user and the total rewards will be returned.
     * @returns The incentive pools information.
     */
    getIncentivePools(asset_id, option, user) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield (0, address_1.getConfig)();
            const result = yield (0, CallFunctions_1.moveInspect)(this.client, this.address, `${config.uiGetter}::incentive_getter::get_incentive_pools`, [
                '0x06', // clock object id
                config.IncentiveV2, // the incentive object v2
                config.StorageId, // object id of storage
                asset_id,
                option,
                user ? user : '0x0000000000000000000000000000000000000000000000000000000000000000', // If you provide your address, the rewards that have been claimed by your address and the total rewards will be returned.
            ], [], // type arguments is null
            'vector<IncentivePoolInfo>' // parse type
            );
            return result[0];
        });
    }
    /**
     * Retrieves the available rewards for a given address.
     *
     * @param toCheckAddress - The address to check for rewards. Defaults to the current address.
     * @param option - The option type. Defaults to 1.
     * @param ifPrettyPrint - Whether to print the rewards in a pretty format. Defaults to true.
     * @returns An object containing the summed rewards for each asset.
     * @throws If there is an error retrieving the available rewards.
     */
    getAvailableRewards(toCheckAddress = this.address, option = 1, ifPrettyPrint = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const assetIds = Array.from({ length: 8 }, (_, i) => i); // Generates an array [0, 1, 2, ..., 7]
            try {
                const allResults = yield Promise.all(assetIds.map(assetId => this.getIncentivePools(assetId, option, toCheckAddress)));
                const allPools = allResults.flat();
                const activePools = allPools.filter(pool => pool.available.trim() != '0');
                const summedRewards = activePools.reduce((acc, pool) => {
                    const assetId = pool.asset_id.toString();
                    // Convert 'available' to a decimal number with 5 decimal places
                    const availableDecimal = (BigInt(pool.available) / BigInt(Math.pow(10, 27))).toString();
                    const availableFixed = (Number(availableDecimal) / Math.pow(10, 9)).toFixed(5); // Adjust for 5 decimal places
                    if (!acc[assetId]) {
                        acc[assetId] = { asset_id: assetId, funds: pool.funds, available: availableFixed };
                    }
                    else {
                        // Sum available while preserving 5 decimal places
                        acc[assetId].available = (parseFloat(acc[assetId].available) + parseFloat(availableFixed)).toFixed(5);
                    }
                    return acc;
                }, {});
                if (ifPrettyPrint) {
                    const coinDictionary = {
                        '0': 'Sui',
                        '1': 'USDC',
                        '2': 'USDT',
                        '3': 'WETH',
                        '4': 'CETUS',
                        '5': 'vSui',
                        '6': 'haSui',
                        '7': 'NAVX',
                    };
                    console.log(toCheckAddress, ' available rewards:');
                    Object.keys(summedRewards).forEach(key => {
                        if (key == '5' || key == '7') {
                            console.log(`${coinDictionary[key]}: ${summedRewards[key].available} NAVX`);
                        }
                        else {
                            console.log(`${coinDictionary[key]}: ${summedRewards[key].available} vSui`);
                        }
                    });
                }
                return summedRewards;
            }
            catch (error) {
                console.error('Failed to get available rewards:', error);
                throw error;
            }
        });
    }
    /**
     * Claims all available rewards for the specified account.
     * @returns A promise that resolves to the result of the reward claim operation.
     */
    claimAllRewards() {
        return __awaiter(this, void 0, void 0, function* () {
            let txb = new transactions_1.TransactionBlock();
            txb.setSender(this.address);
            const rewardsSupply = yield this.getAvailableRewards(this.address, 1, false);
            for (const reward of rewardsSupply) {
                yield (0, PTB_1.claimRewardFunction)(txb, reward.funds, reward.asset_id, 1);
            }
            const rewardsBorrow = yield this.getAvailableRewards(this.address, 3, false);
            for (const reward of rewardsBorrow) {
                yield (0, PTB_1.claimRewardFunction)(txb, reward.funds, reward.asset_id, 3);
            }
            const result = (0, PTB_1.SignAndSubmitTXB)(txb, this.client, this.keypair);
            return result;
        });
    }
}
exports.AccountManager = AccountManager;
