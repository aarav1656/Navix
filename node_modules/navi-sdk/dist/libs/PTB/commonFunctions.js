"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignAndSubmitTXB = exports.claimRewardFunction = exports.liquidateFunction = exports.repayFlashLoan = exports.flashloan = exports.mergeCoins = exports.getHealthFactor = exports.repayDebt = exports.borrowCoin = exports.withdrawCoinWithAccountCap = exports.withdrawCoin = exports.depositCoinWithAccountCap = exports.depositCoin = void 0;
const address_1 = require("../../address");
/**
 * Deposits a specified amount of a coin into a pool.
 * @param txb - The transaction block object.
 * @param _pool - The pool configuration object.
 * @param coinObject - The object representing the coin you own.
 * @param amount - The amount of the coin to deposit.
 * @returns The updated transaction block object.
 */
function depositCoin(txb, _pool, coinObject, amount) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        txb.moveCall({
            target: `${config.ProtocolPackage}::incentive_v2::entry_deposit`,
            arguments: [
                txb.object('0x06'), // clock object id
                txb.object(config.StorageId), // object id of storage
                txb.object(_pool.poolId), // pool id of the asset
                txb.pure(_pool.assetId), // the id of the asset in the protocol
                coinObject, // the object id of the Coin you own.
                txb.pure(amount), // The amount you want to deposit, decimals must be carried, like 1 sui => 1000000000
                txb.object(config.Incentive),
                txb.object(config.IncentiveV2), // The incentive object v2
            ],
            typeArguments: [_pool.type]
        });
        return txb;
    });
}
exports.depositCoin = depositCoin;
/**
 * Deposits a coin with account cap.
 * @param txb - The transaction block object.
 * @param _pool - The pool configuration object.
 * @param coinObject - The object representing the coin you own.
 * @param account - The account to deposit the coin into.
 * @returns The updated transaction block object.
 */
function depositCoinWithAccountCap(txb, _pool, coinObject, account) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        txb.moveCall({
            target: `${config.ProtocolPackage}::incentive_v2::deposit_with_account_cap`,
            arguments: [
                txb.object('0x06'), // clock object id
                txb.object(config.StorageId), // object id of storage
                txb.object(_pool.poolId), // pool id of the asset
                txb.pure(_pool.assetId), // the id of the asset in the protocol
                coinObject, // the object id of the Coin you own.
                txb.object(config.Incentive),
                txb.object(config.IncentiveV2), // The incentive object v2
                txb.object(account)
            ],
            typeArguments: [_pool.type]
        });
        return txb;
    });
}
exports.depositCoinWithAccountCap = depositCoinWithAccountCap;
/**
 * Withdraws a specified amount of coins from a pool.
 *
 * @param txb - The transaction block object.
 * @param _pool - The pool configuration object.
 * @param amount - The amount of coins to withdraw.
 * @returns The updated transaction block object.
 */
function withdrawCoin(txb, _pool, amount) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        const [ret] = txb.moveCall({
            target: `${config.ProtocolPackage}::incentive_v2::withdraw`,
            arguments: [
                txb.object('0x06'), // clock object id
                txb.object(config.PriceOracle), // object id of oracle
                txb.object(config.StorageId), // object id of storage
                txb.object(_pool.poolId), // pool id of the asset
                txb.pure(_pool.assetId), // the id of the asset in the protocol
                txb.pure(amount), // The amount you want to withdraw, decimals must be carried, like 1 sui => 1000000000
                txb.object(config.Incentive),
                txb.object(config.IncentiveV2), // The incentive object v2
            ],
            typeArguments: [_pool.type]
        });
        //Transfer withdraw
        const [coin] = txb.moveCall({
            target: `0x2::coin::from_balance`,
            arguments: [ret],
            typeArguments: [_pool.type]
        });
        return [coin];
    });
}
exports.withdrawCoin = withdrawCoin;
/**
 * Withdraws a specified amount of coins from an account with an account cap.
 * @param txb - The TransactionBlock object.
 * @param _pool - The PoolConfig object.
 * @param account - The account from which to withdraw the coins.
 * @param withdrawAmount - The amount of coins to withdraw.
 * @param sender - The sender of the transaction.
 */
function withdrawCoinWithAccountCap(txb, _pool, account, withdrawAmount, sender) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        const [ret] = txb.moveCall({
            target: `${config.ProtocolPackage}::incentive_v2::withdraw_with_account_cap`,
            arguments: [
                txb.sharedObjectRef({
                    objectId: '0x06',
                    initialSharedVersion: 1,
                    mutable: false,
                }), // clock object id
                txb.object(config.PriceOracle), // object id of oracle
                txb.object(config.StorageId), // object id of storage
                txb.object(_pool.poolId), // pool id of the asset
                txb.pure(_pool.assetId), // the id of the asset in the protocol
                txb.pure(withdrawAmount), // The amount you want to withdraw, decimals must be carried, like 1 sui => 1000000000
                txb.object(config.Incentive),
                txb.object(config.IncentiveV2), // The incentive object v2
                txb.object(account)
            ],
            typeArguments: [_pool.type]
        });
        // const [ret] = txb.moveCall({ target: `${config.ProtocolPackage}::lending::create_account` });
        const [coin] = txb.moveCall({
            target: `0x2::coin::from_balance`,
            arguments: [txb.object(ret)],
            typeArguments: [_pool.type]
        });
        return [coin];
    });
}
exports.withdrawCoinWithAccountCap = withdrawCoinWithAccountCap;
/**
 * Borrows a specified amount of coins from a pool.
 * @param txb - The transaction block object.
 * @param _pool - The pool configuration object.
 * @param borrowAmount - The amount of coins to borrow.
 * @returns The updated transaction block object.
 */
function borrowCoin(txb, _pool, borrowAmount) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        const [ret] = txb.moveCall({
            target: `${config.ProtocolPackage}::incentive_v2::borrow`,
            arguments: [
                txb.object('0x06'), // clock object id
                txb.object(config.PriceOracle), // object id of oracle
                txb.object(config.StorageId), // object id of storage
                txb.object(_pool.poolId), // pool id of the asset
                txb.pure(_pool.assetId), // the id of the asset in the protocol
                txb.pure(borrowAmount), // The amount you want to borrow, decimals must be carried, like 1 sui => 1000000000
                txb.object(config.IncentiveV2), // The incentive object v2
            ],
            typeArguments: [_pool.type]
        });
        const [coin] = txb.moveCall({
            target: `0x2::coin::from_balance`,
            arguments: [txb.object(ret)],
            typeArguments: [_pool.type]
        });
        return [coin];
    });
}
exports.borrowCoin = borrowCoin;
/**
 * Repays a debt in the protocol.
 * @param txb - The transaction block object.
 * @param _pool - The pool configuration object.
 * @param coinObject - The object representing the Coin you own.
 * @param repayAmount - The amount you want to repay.
 * @returns The updated transaction block object.
 */
function repayDebt(txb, _pool, coinObject, repayAmount) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        txb.moveCall({
            target: `${config.ProtocolPackage}::incentive_v2::entry_repay`,
            arguments: [
                txb.object('0x06'), // clock object id
                txb.object(config.PriceOracle), // object id of oracle
                txb.object(config.StorageId), // object id of storage
                txb.object(_pool.poolId), // pool id of the asset
                txb.pure(_pool.assetId), // the id of the asset in the protocol
                coinObject, // the object id of the Coin you own.
                txb.pure(repayAmount), // The amount you want to borrow, decimals must be carried, like 1 sui => 1000000000
                txb.object(config.IncentiveV2), // The incentive object v2
            ],
            typeArguments: [_pool.type]
        });
        return txb;
    });
}
exports.repayDebt = repayDebt;
/**
 * Retrieves the health factor for a given address.
 * @param txb - The TransactionBlock object.
 * @param address - The address for which to retrieve the health factor.
 * @returns The health factor balance.
 */
function getHealthFactor(txb, address) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        const balance = txb.moveCall({
            target: `${config.ProtocolPackage}::logic::user_health_factor`,
            arguments: [
                txb.object('0x06'), // clock object id
                txb.object(config.StorageId), // object id of storage
                txb.object(config.PriceOracle), // Object id of Price Oracle
                txb.pure(address)
            ],
        });
        return balance;
    });
}
exports.getHealthFactor = getHealthFactor;
/**
 * Merges multiple coins into a single coin object.
 *
 * @param txb - The transaction block object.
 * @param coinInfo - The coin information object.
 * @returns The merged coin object.
 */
function mergeCoins(txb, coinInfo) {
    if (coinInfo.data.length >= 2) {
        let baseObj = coinInfo.data[0].coinObjectId;
        let i = 1;
        while (i < coinInfo.data.length) {
            txb.mergeCoins(baseObj, [coinInfo.data[i].coinObjectId]);
            i++;
        }
    }
    let mergedCoinObject = txb.object(coinInfo.data[0].coinObjectId);
    return mergedCoinObject;
}
exports.mergeCoins = mergeCoins;
/**
 * Executes a flash loan transaction.
 * @param txb - The TransactionBlock object.
 * @param _pool - The PoolConfig object representing the pool.
 * @param amount - The amount of the flash loan.
 * @returns An array containing the balance and receipt of the flash loan transaction.
 */
function flashloan(txb, _pool, amount) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        const [balance, receipt] = txb.moveCall({
            target: `${config.ProtocolPackage}::lending::flash_loan_with_ctx`,
            arguments: [
                txb.object(address_1.flashloanConfig.id), // clock object id
                txb.object(_pool.poolId), // pool id of the asset
                txb.pure(amount), // the id of the asset in the protocol
            ],
            typeArguments: [_pool.type]
        });
        return [balance, receipt];
    });
}
exports.flashloan = flashloan;
/**
 * Repays a flash loan by calling the flash_repay_with_ctx function in the lending protocol.
 *
 * @param txb - The TransactionBlock object.
 * @param _pool - The PoolConfig object representing the pool.
 * @param receipt - The receipt object.
 * @param repayCoin - The asset ID of the asset to be repaid.
 * @returns The balance after the flash loan is repaid.
 */
function repayFlashLoan(txb, _pool, receipt, repayCoin) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        const [balance] = txb.moveCall({
            target: `${config.ProtocolPackage}::lending::flash_repay_with_ctx`,
            arguments: [
                txb.object('0x06'), // clock object id
                txb.object(config.StorageId),
                txb.object(_pool.poolId), // pool id of the asset
                receipt,
                repayCoin, // the id of the asset in the protocol
            ],
            typeArguments: [_pool.type]
        });
        return [balance];
    });
}
exports.repayFlashLoan = repayFlashLoan;
/**
 * Liquidates a transaction block by calling the entry_liquidation function.
 * @param txb - The transaction block to be liquidated.
 * @param payCoinType - The coin type used for payment.
 * @param payCoinObj - The payment coin object.
 * @param collateralCoinType - The coin type used for collateral.
 * @param to_liquidate_address - The address to which the liquidated amount will be sent.
 * @param to_liquidate_amount - The amount to be liquidated.
 */
function liquidateFunction(txb, payCoinType, payCoinObj, collateralCoinType, to_liquidate_address, to_liquidate_amount) {
    return __awaiter(this, void 0, void 0, function* () {
        const pool_to_pay = address_1.pool[payCoinType.symbol];
        const collateral_pool = address_1.pool[collateralCoinType.symbol];
        const config = yield (0, address_1.getConfig)();
        txb.moveCall({
            target: `${config.ProtocolPackage}::incentive_v2::entry_liquidation`,
            arguments: [
                txb.object('0x06'),
                txb.object(config.PriceOracle),
                txb.object(config.StorageId),
                txb.pure(pool_to_pay.assetId),
                txb.object(pool_to_pay.poolId),
                payCoinObj,
                txb.pure(collateral_pool.assetId),
                txb.object(collateral_pool.poolId),
                txb.pure(to_liquidate_address),
                txb.pure(to_liquidate_amount),
                txb.object(config.Incentive),
                txb.object(config.IncentiveV2),
            ],
            typeArguments: [pool_to_pay.type, collateral_pool.type],
        });
    });
}
exports.liquidateFunction = liquidateFunction;
/**
 * Claims the reward for a transaction block.
 * @param txb - The transaction block.
 * @param incentiveFundsPool - The incentive funds pool.
 * @param assetId - The asset ID.
 * @param option - The option type.
 */
function claimRewardFunction(txb, incentiveFundsPool, assetId, option) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield (0, address_1.getConfig)();
        const ProFundsPoolInfo = {
            'f975bc2d4cca10e3ace8887e20afd77b46c383b4465eac694c4688344955dea4': {
                coinType: '0x2::sui::SUI',
                oracleId: 0,
            },
            'e2b5ada45273676e0da8ae10f8fe079a7cec3d0f59187d3d20b1549c275b07ea': {
                coinType: '0x549e8b69270defbfafd4f94e17ec44cdbdd99820b33bda2278dea3b9a32d3f55::cert::CERT',
                oracleId: 5,
            },
            'a20e18085ce04be8aa722fbe85423f1ad6b1ae3b1be81ffac00a30f1d6d6ab51': {
                coinType: '0xbde4ba4c2e274a60ce15c1cfff9e5c42e41654ac8b6d906a57efa4bd3c29f47d::hasui::HASUI',
                oracleId: 6,
            },
            '9dae0cf104a193217904f88a48ce2cf0221e8cd9073878edd05101d6b771fa09': {
                coinType: '0xa99b8952d4f7d947ea77fe0ecdcc9e5fc0bcab2841d6e2a5aa00c3044e5544b5::navx::NAVX',
                oracleId: 7,
            },
        };
        txb.moveCall({
            target: `${config.ProtocolPackage}::incentive_v2::claim_reward`,
            arguments: [
                txb.object('0x06'),
                txb.object(config.IncentiveV2),
                txb.object(`0x${incentiveFundsPool}`),
                txb.object(config.StorageId),
                txb.pure(assetId),
                txb.pure(option),
            ],
            typeArguments: [ProFundsPoolInfo[incentiveFundsPool].coinType],
        });
    });
}
exports.claimRewardFunction = claimRewardFunction;
/**
 * Signs and submits a transaction block using the provided client and keypair.
 * @param txb - The transaction block to sign and submit.
 * @param client - The client object used to sign and execute the transaction block.
 * @param keypair - The keypair used as the signer for the transaction block.
 * @returns A promise that resolves to the result of signing and executing the transaction block.
 */
function SignAndSubmitTXB(txb, client, keypair) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield client.signAndExecuteTransactionBlock({
            transactionBlock: txb,
            signer: keypair,
            requestType: 'WaitForLocalExecution',
            options: {
                showEffects: true
            }
        });
        return result;
    });
}
exports.SignAndSubmitTXB = SignAndSubmitTXB;
